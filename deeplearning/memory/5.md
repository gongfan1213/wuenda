### Letta框架中核心内存（Core Memory）的自定义与实现要点总结

#### 1. 核心内存的基础结构
- **内存块（Memory Blocks）**：  
  核心内存被划分为多个内存块，每个块包含：  
  - **标签（Label）**：如“human”“persona”“tasks”，用于标识块的用途。  
  - **字符限制（Character Limit）**：定义该块在上下文窗口中占用的最大字符数（默认5k），防止上下文溢出。  
  - **值（Value）**：实际存储的数据（如用户信息、任务列表），格式可自定义（如文本、JSON）。  
- **内存工具（Memory Tools）**：  
  用于操作内存块的工具，如`core_memory_replace`（替换内容）、`core_memory_append`（追加内容），可自定义扩展。  


#### 2. 内存块的管理与访问
- **查看内存块**：  
  通过`client.blocks.list(agent_id)`获取代理的所有内存块，包含块ID、标签、字符限制和当前值。  
- **直接访问**：  
  - 可通过**块ID**（`client.blocks.get(block_id)`）或**标签+代理ID**（`client.blocks.get_by_label(agent_id, label)`）精准获取特定块。  
- **同步与共享**：  
  内存块通过唯一ID同步到数据库，支持跨代理共享（将同一内存块同步到多个代理的上下文窗口）。  


#### 3. 上下文窗口中的内存块渲染
- **渲染模板**：  
  内存块在上下文窗口中以特定格式渲染，包含标签、已用字符/总限制、值。例如：  
  ```  
  <human [50/1000 chars]>My name is Sarah.</human>  
  ```  
- **自定义模板**：  
  可修改渲染格式，调整标签显示方式或字符限制的提示方式，以适应代理的特定需求。  


#### 4. 有状态工具（Stateful Tools）的定义与使用
- **概念**：  
  有状态工具能访问并修改代理的内部状态（如内存块、对话历史），通过`agent_state`参数注入代理状态。  
- **示例：获取代理ID的工具**：  
  ```python  
  def get_agent_id(agent_state):  
      """获取代理的ID。"""  
      return agent_state.agent_id  

  # 注册工具  
  client.tools.upsert_from_function(get_agent_id)  
  ```  
  - 工具通过`agent_state`访问代理的元数据（如ID），无需手动传入。  
  - 调用时，代理会自动注入`agent_state`参数，LLM无需知晓其存在。  


#### 5. 自定义核心内存管理（以任务队列为例）
- **场景**：  
  创建一个“任务队列”内存块，通过自定义工具`task_queue_push`和`task_queue_pop`管理任务列表。  

- **步骤1：定义自定义工具**  
  - **`task_queue_push`**：  
    接收任务描述，将其追加到“tasks”内存块（JSON格式的列表）。  
    ```python  
    def task_queue_push(agent_state, task_description: str):  
        """向任务队列添加新任务。"""  
        client = Letta()  # 工具内部实例化客户端  
        # 获取“tasks”内存块  
        task_block = client.blocks.get_by_label(agent_state.agent_id, "tasks")  
        tasks = json.loads(task_block.value)  # 解析JSON列表  
        tasks.append(task_description)  # 追加新任务  
        # 更新内存块  
        client.blocks.modify(task_block.id, value=json.dumps(tasks))  
    ```  

  - **`task_queue_pop`**：  
    从任务队列中移除并返回第一个任务，更新剩余任务列表。  
    ```python  
    def task_queue_pop(agent_state):  
        """从任务队列移除并返回第一个任务。"""  
        client = Letta()  
        task_block = client.blocks.get_by_label(agent_state.agent_id, "tasks")  
        tasks = json.loads(task_block.value)  
        if not tasks:  
            return None  
        popped_task = tasks.pop(0)  # 移除第一个任务  
        client.blocks.modify(task_block.id, value=json.dumps(tasks))  
        return popped_task  
    ```  

- **步骤2：创建自定义代理**  
  - 禁用默认工具（`include_base_tools=False`），仅启用自定义任务工具。  
  - 初始化“tasks”内存块为空JSON列表。  
  - 自定义系统提示，描述任务队列的管理逻辑。  

- **步骤3：交互示例**  
  - 向代理发送指令：“添加两个任务：‘称呼我为Charles’和‘为我的名字写一首俳句’”。  
  - 代理调用`task_queue_push`添加任务，再通过`task_queue_pop`依次执行，最终返回结果。  


#### 6. 关键优势与扩展方向
- **优势**：  
  - 自定义内存块和工具使代理能按需管理状态（如任务、用户偏好），适应复杂场景。  
  - 有状态工具支持跨步骤的状态持久化，突破LLM上下文窗口的瞬时性限制。  
- **扩展方向**：  
  - 设计更复杂的内存结构（如分层任务、用户画像细分）。  
  - 结合外部数据库，实现内存块与外部数据的同步（如将任务队列与项目管理系统关联）。  


#### 总结
通过Letta框架，可灵活定义内存块结构和操作工具，实现核心内存的自定义管理。以任务队列为例，展示了如何通过有状态工具让代理具备跨步骤的状态管理能力，为构建复杂、持久化的AI代理提供了强大支持。
